{
  "version": 3,
  "sources": ["../../whatsapp-chat-parser/src/utils.ts", "../../whatsapp-chat-parser/src/date.ts", "../../whatsapp-chat-parser/src/time.ts", "../../whatsapp-chat-parser/src/parser.ts", "../../whatsapp-chat-parser/src/index.ts"],
  "sourcesContent": ["/**\n * Checks that the number at a certain index of an array is greater than a\n * certain value.\n */\nfunction indexAboveValue(index: number, value: number) {\n  return (array: number[]): boolean => array[index] > value;\n}\n\n/**\n * Returns `true` for a negative number, `false` otherwise.\n *\n * `0` and `-0` are considered positive.\n */\nfunction isNegative(number: number): boolean {\n  return number < 0;\n}\n\n/**\n * Takes an array of arrays and an index and groups the inner arrays by the\n * value at the index provided.\n * @see `utils.test.ts` for a better understanding of this function.\n */\nfunction groupArrayByValueAtIndex<T extends unknown[]>(\n  array: T[],\n  index: number,\n): T[][] {\n  return Object.values(\n    array.reduce((obj: { [key: string]: T[] }, item) => {\n      /*\n       * Keys that are numbers (even strings containing a number) get sorted\n       * when using `Object.values()`.\n       * Adding a prefix avoids this issue.\n       */\n      const key = `_${item[index]}`;\n\n      if (!obj[key]) obj[key] = [];\n\n      obj[key].push(item);\n\n      return obj;\n    }, {}),\n  );\n}\n\nexport { indexAboveValue, isNegative, groupArrayByValueAtIndex };\n", "import { indexAboveValue, isNegative, groupArrayByValueAtIndex } from './utils';\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by checking if numbers go above\n * `12`.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction checkAbove12(numericDates: number[][]): boolean | null {\n  const daysFirst = numericDates.some(indexAboveValue(0, 12));\n\n  if (daysFirst) return true;\n\n  const daysSecond = numericDates.some(indexAboveValue(1, 12));\n\n  if (daysSecond) return false;\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by checking if a set of numbers\n * during the same year decrease at some point.\n *\n * If it does it's probably the days since months can only increase in a given\n * year.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction checkDecreasing(numericDates: number[][]): boolean | null {\n  const datesByYear = groupArrayByValueAtIndex(numericDates, 2);\n  const results = datesByYear.map(dates => {\n    const daysFirst = dates.slice(1).some((date, i) => {\n      const [first1] = dates[i];\n      const [first2] = date;\n\n      return isNegative(first2 - first1);\n    });\n\n    if (daysFirst) return true;\n\n    const daysSecond = dates.slice(1).some((date, i) => {\n      const [, second1] = dates[i];\n      const [, second2] = date;\n\n      return isNegative(second2 - second1);\n    });\n\n    if (daysSecond) return false;\n\n    return null;\n  });\n\n  const anyTrue = results.some(value => value === true);\n\n  if (anyTrue) return true;\n\n  const anyFalse = results.some(value => value === false);\n\n  if (anyFalse) return false;\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by looking at which number changes\n * more frequently.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction changeFrequencyAnalysis(numericDates: number[][]): boolean | null {\n  const diffs = numericDates\n    .slice(1)\n    .map((date, i) => date.map((num, j) => Math.abs(numericDates[i][j] - num)));\n  const [first, second] = diffs.reduce(\n    (total, diff) => {\n      const [first1, second1] = total;\n      const [first2, second2] = diff;\n\n      return [first1 + first2, second1 + second2];\n    },\n    [0, 0],\n  );\n\n  if (first > second) return true;\n  if (first < second) return false;\n\n  return null;\n}\n\n/**\n * Takes an array of numeric dates and tries to understand if the days come\n * before the month or the other way around by running the dates through various\n * checks.\n *\n * Output is `true` if days are first, `false` if they are second, or `null` if\n * it failed to understand the order.\n */\nfunction daysBeforeMonths(numericDates: number[][]): boolean | null {\n  const firstCheck = checkAbove12(numericDates);\n\n  if (firstCheck !== null) return firstCheck;\n\n  const secondCheck = checkDecreasing(numericDates);\n\n  if (secondCheck !== null) return secondCheck;\n\n  return changeFrequencyAnalysis(numericDates);\n}\n\n/**\n * Takes `year`, `month` and `day` as strings and pads them to `4`, `2`, `2`\n * digits respectively.\n */\nfunction normalizeDate(\n  year: string,\n  month: string,\n  day: string,\n): [string, string, string] {\n  return [\n    // 2 digit years are assumed to be in the 2000-2099 range\n    year.padStart(4, '2000'),\n    month.padStart(2, '0'),\n    day.padStart(2, '0'),\n  ];\n}\n\n/**\n * Pushes the longest number in a date to the end, if there is one. Necessary to\n * ensure the year is the last number.\n */\nfunction orderDateComponents(date: string): [string, string, string] {\n  const regexSplitDate = /[-/.] ?/;\n  const [a, b, c] = date.split(regexSplitDate);\n  const maxLength = Math.max(a.length, b.length, c.length);\n\n  if (c.length === maxLength) return [a, b, c];\n  if (b.length === maxLength) return [a, c, b];\n  return [b, c, a];\n}\n\nexport {\n  checkAbove12,\n  checkDecreasing,\n  changeFrequencyAnalysis,\n  daysBeforeMonths,\n  normalizeDate,\n  orderDateComponents,\n};\n", "const regexSplitTime = /[:.]/;\n\n/**\n * Converts time from 12 hour format to 24 hour format.\n *\n * Reference:\n * {@link https://stackoverflow.com/a/40197728/5303634}\n */\nfunction convertTime12to24(time: string, ampm: string): string {\n  // eslint-disable-next-line prefer-const\n  let [hours, minutes, seconds] = time.split(regexSplitTime);\n\n  if (hours === '12') hours = '00';\n  if (ampm === 'PM') hours = String(parseInt(hours, 10) + 12);\n\n  return `${hours}:${minutes}${seconds ? `:${seconds}` : ''}`;\n}\n\n/**\n * Normalizes a time string to have the following format: `hh:mm:ss`.\n */\nfunction normalizeTime(time: string): string {\n  const [hours, minutes, seconds] = time.split(regexSplitTime);\n\n  return `${hours.padStart(2, '0')}:${minutes}:${seconds || '00'}`;\n}\n\n/**\n * Normalizes `am` / `a.m.` / etc. to `AM` (uppercase, no other characters).\n */\nfunction normalizeAMPM(ampm: string): string {\n  return ampm.replace(/[^apm]/gi, '').toUpperCase();\n}\n\nexport { regexSplitTime, convertTime12to24, normalizeTime, normalizeAMPM };\n", "import { daysBeforeMonths, normalizeDate, orderDateComponents } from './date';\nimport {\n  regexSplitTime,\n  convertTime12to24,\n  normalizeAMPM,\n  normalizeTime,\n} from './time';\nimport { Attachment, Message, RawMessage, ParseStringOptions } from './types';\n\nconst sharedRegex =\n  /^(?:\\u200E|\\u200F)*\\[?(\\d{1,4}[-/.]\\s?\\d{1,4}[-/.]\\s?\\d{1,4})[,.]?\\s\\D*?(\\d{1,2}[.:]\\d{1,2}(?:[.:]\\d{1,2})?)(?:\\s([ap]\\.?\\s?m\\.?))?\\]?(?:\\s-|:)?\\s/;\nconst authorAndMessageRegex = /(.+?):\\s([^]*)/;\nconst messageRegex = /([^]+)/;\nconst regexParser = new RegExp(\n  sharedRegex.source + authorAndMessageRegex.source,\n  'i',\n);\nconst regexParserSystem = new RegExp(\n  sharedRegex.source + messageRegex.source,\n  'i',\n);\nconst regexAttachment = /<.+:(.+)>|([A-Z\\d-]+\\.\\w+)\\s[(<].+[)>]/;\n\n/**\n * Takes an array of lines and detects the lines that are part of a previous\n * message (multiline messages) and merges them.\n *\n * It also labels messages without an author as system messages.\n */\nfunction makeArrayOfMessages(lines: string[]): RawMessage[] {\n  return lines.reduce((acc: RawMessage[], line) => {\n    /*\n     * If the line doesn't match the regex it's probably part of the previous\n     * message or a \"WhatsApp event\"\n     */\n    if (!regexParser.test(line)) {\n      /*\n       * If it doesn't match the first regex but still matches the system regex\n       * it should be considered a \"WhatsApp event\" so it gets labeled \"system\"\n       */\n      if (regexParserSystem.test(line)) {\n        acc.push({ system: true, msg: line });\n      }\n\n      // Else it's part of the previous message and it should be concatenated\n      else if (typeof acc[acc.length - 1] !== 'undefined') {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const prevMessage = acc.pop()!;\n\n        acc.push({\n          system: prevMessage.system,\n          msg: `${prevMessage.msg}\\n${line}`,\n        });\n      }\n    } else {\n      acc.push({ system: false, msg: line });\n    }\n\n    return acc;\n  }, []);\n}\n\n/**\n * Parses a message extracting the attachment if it's present.\n */\nfunction parseMessageAttachment(message: string): Attachment | null {\n  const attachmentMatch = message.match(regexAttachment);\n\n  if (!attachmentMatch) return null;\n  return {\n    fileName: (attachmentMatch[1] || attachmentMatch[2]).trim(),\n  };\n}\n\n/**\n * Parses and array of raw messages into an array of structured objects.\n */\nfunction parseMessages(\n  messages: RawMessage[],\n  options: ParseStringOptions = {},\n): Message[] {\n  let { daysFirst } = options;\n  const { parseAttachments } = options;\n\n  // Parse messages with regex\n  const parsed = messages.map(obj => {\n    const { system, msg } = obj;\n\n    // If it's a system message another regex should be used to parse it\n    if (system) {\n      const [, date, time, ampm, message] = regexParserSystem.exec(\n        msg,\n      ) as RegExpExecArray;\n\n      return { date, time, ampm: ampm || null, author: null, message };\n    }\n\n    const [, date, time, ampm, author, message] = regexParser.exec(\n      msg,\n    ) as RegExpExecArray;\n\n    return { date, time, ampm: ampm || null, author, message };\n  });\n\n  // Understand date format if not supplied (do days come first?)\n  if (typeof daysFirst !== 'boolean') {\n    const numericDates = Array.from(\n      new Set(parsed.map(({ date }) => date)),\n      date => orderDateComponents(date).map(Number),\n    );\n\n    daysFirst = daysBeforeMonths(numericDates);\n  }\n\n  // Convert date and time in a `Date` object, return the final object\n  return parsed.map(({ date, time, ampm, author, message }) => {\n    let day: string;\n    let month: string;\n    let year: string;\n    const splitDate = orderDateComponents(date);\n\n    if (daysFirst === false) {\n      [month, day, year] = splitDate;\n    } else {\n      [day, month, year] = splitDate;\n    }\n\n    [year, month, day] = normalizeDate(year, month, day);\n\n    const [hours, minutes, seconds] = normalizeTime(\n      ampm ? convertTime12to24(time, normalizeAMPM(ampm)) : time,\n    ).split(regexSplitTime);\n\n    const finalObject: Message = {\n      date: new Date(+year, +month - 1, +day, +hours, +minutes, +seconds),\n      author,\n      message,\n    };\n\n    // Optionally parse attachments\n    if (parseAttachments) {\n      const attachment = parseMessageAttachment(message);\n      if (attachment) finalObject.attachment = attachment;\n    }\n\n    return finalObject;\n  });\n}\n\nexport { makeArrayOfMessages, parseMessages };\n", "import { makeArrayOfMessages, parseMessages } from './parser';\nimport { Attachment, Message, ParseStringOptions } from './types';\n\nconst newlinesRegex = /(?:\\r\\n|\\r|\\n)/;\n\n/**\n * Parses a string containing a WhatsApp chat log.\n *\n * Returns an array of parsed messages.\n *\n * @since 3.2.0\n * @since 4.0.0 Renamed from parseStringSync\n */\nexport function parseString(\n  string: string,\n  options: ParseStringOptions = { parseAttachments: false },\n): Message[] {\n  const lines = string.split(newlinesRegex);\n  return parseMessages(makeArrayOfMessages(lines), options);\n}\n\nexport type { Attachment, Message, ParseStringOptions };\n"],
  "mappings": "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",
  "names": ["indexAboveValue", "index", "value", "array", "isNegative", "number", "groupArrayByValueAtIndex", "obj", "item", "key", "checkAbove12", "numericDates", "checkDecreasing", "results", "dates", "date", "i", "first1", "first2", "second1", "second2", "changeFrequencyAnalysis", "diffs", "num", "j", "first", "second", "total", "diff", "daysBeforeMonths", "firstCheck", "secondCheck", "normalizeDate", "year", "month", "day", "orderDateComponents", "regexSplitDate", "a", "b", "c", "maxLength", "regexSplitTime", "convertTime12to24", "time", "ampm", "hours", "minutes", "seconds", "normalizeTime", "normalizeAMPM", "sharedRegex", "authorAndMessageRegex", "messageRegex", "regexParser", "regexParserSystem", "regexAttachment", "makeArrayOfMessages", "lines", "acc", "line", "prevMessage", "parseMessageAttachment", "message", "attachmentMatch", "parseMessages", "messages", "options", "daysFirst", "parseAttachments", "parsed", "system", "msg", "author", "splitDate", "finalObject", "attachment", "newlinesRegex", "parseString", "string"]
}
